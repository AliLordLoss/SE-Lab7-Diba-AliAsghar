<div dir="rtl">
# آزمایش هفتم - آز نرم

## گزارش

### دو مورد اعمال الگوی Facade
در کلاس SymbolTable دو کلاس تعریف شده بود، یکی Klass و دیگری Method، و این کلاس به متغیرهای درون این کلاس‌ها دسترسی 
کامل داشت و از آنها استفاده می‌کرد. هر دوی این کلاس‌ها به یک فایل مجزا منتقل شدند، attributeهای آنها private شدند و 
نیز کد مربوط به قسمت‌هایی که با attributeهای این کلاس‌ها کار داشتند و پیچیدگی‌های مربوط به آنها به درون متدهای این 
کلاس‌ها انتقال داده شد و از این متدها به جای دسترسی مستقیم استفاده شد. پس دو مورد اعمال الگوی facade در این قسمت 
انجام شد.

### یک مورد State/Strategy یا استفاده از Polymorphism به جای شرط
در کلاس Address، برای آن یک type تعریف شده بود که تنها در متد toString بر اساس این type، مقداری را محاسبه و 
return می‌کرد. این متغیر حذف شد و به جای آن، دو کلاس جدید که از Address ارث‌بری می‌کردند ساخته شدند و متد toString 
آن را Override کردند.

### یک مورد Separate Query From Modifier
در کلاس Memory یک تابع به نام getDataAddress وجود داشت که هم متغیری را برمی‌گرداند و هم آن را تغیر می‌داد. این تابع 
تبدیل به دو تابع مجزا شد.

### سه مورد از سایر بازآرایی‌ها
* extract method

در کلاس CodeGenerator یک متد شلوغ وجود داشت که قسمتی از آن منطق معینی داشت، لذا این قسمت استخراج شد و به یک متد مجزا 
منتقل شد که تنها این متد فراخوانی می‌شد.

* introduce null object

اشیا از نوع Symbol گاهی null بودند و در کد با استفاده از شرط این قضیه چک می‌شد. به جای این کار یک کلاس که از Symbol 
ارث‌بری می‌کرد با نام NullSymbol ساخته شد و متد isNull در هر دوی این کلاس‌ها پیاده‌سازی شد؛ به طوری که در کلاس Symbol 
مقدار false و در کلاس NullSymbol مقدار true را برگرداند. در نهایت همه جاهایی که مقدار Symbol را برابر با null قرار 
داده بودند، از NullSymbol به جای آن استفاده شد.

* replace type code with subclass

کلاس GrammarSymbol یک متغیر از نوع boolean داشت که isTerminal نام داشت. این متغیر حذف شد و کلاس به interface تغیر 
داده شد، سپس دو کلاس که این interface را پیاده‌سازی می‌کردند ساخته شدند: TerminalGrammarSymbol و 
NonTerminalGrammarSymbol.
در این دو کلاس تابع isTerminal که در interface تعریف شده بود پیاده‌سازی شد؛ که در کلاس اول true و در کلاس دوم false 
برمی‌گرداند.

## پرسش ها
### سوال 1

کد تمیز: کدی است که درک و برداشت از آن راحت تر است و خوانا تر می باشد.

بدهی فنی: آن قسمت از کد که میبایستی ببهینه شود و در غیر این صورت منجر به افزابش هزینه ها خواهد شد.

بوی بد: زمانی که طراحی کد ساختار ضعیفی دارد.

### سوال 2
مورد اول Couplers هستند که نشان دهنده وابستگی های بیش از حد بین ماژول ها یا کلاس های مختلف است.
دوم  Change Preventers هستند که زمانی رخ میدهد که تغییر واگرا شود، یا سلسله مراتب وراثت موازی داشته باشیم.
سوم  Bloaters اندازه کد بزرگ است یا پیچیدگی آن زیاد است.
چهارم Object-Orientation Abusers زمانی که اصول برنامه نویسی اشیا نقض میشود.
پنجم،  Dispensables کدهای غیرضروری یا کد مرده هستند. 

### سوال 3
 این LAZY CLASS زیر مجموعه همین پنجمین کتگوری  Dispensables می شود.
 
 
 برای از بین بردن این بوی بد بهتر است با کلاس های دیگر ادغام شود.
 زمانی میتوان نادیده گرفت که یا به صورت جدی در مرحله طراحی آمده باشد یا اینکه در توابع آینده ممکن باشد به آن نیاز شود.
